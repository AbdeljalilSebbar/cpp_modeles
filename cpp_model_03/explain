Excellent question ğŸ‘ â€” letâ€™s build this up carefully, step by step.

---

### ğŸ§  **Definition**

**Inheritance** in C++ is a mechanism that allows one class (called the **derived class**) to **reuse** and **extend** the properties and behavior of another class (called the **base class**).

In simple words:

> Itâ€™s like saying: â€œClass B *inherits* everything from Class A, but can add or modify some things.â€

---

### ğŸ§© **Basic Example**

```cpp
#include <iostream>
using namespace std;

// Base class
class Animal {
public:
    void eat() {
        cout << "I can eat!" << endl;
    }
};

// Derived class
class Dog : public Animal {
public:
    void bark() {
        cout << "I can bark!" << endl;
    }
};

int main() {
    Dog dog1;
    dog1.eat();   // inherited from Animal
    dog1.bark();  // defined in Dog
}
```

ğŸŸ¢ **Output:**

```
I can eat!
I can bark!
```

---

### ğŸ“˜ **Explanation**

* `Animal` is the **base class**.
* `Dog` is the **derived class**.
* The keyword `: public Animal` means **Dog publicly inherits** from `Animal`.
* Because of inheritance, `Dog` automatically gets access to `Animal`â€™s `eat()` function â€” no need to rewrite it!

---

### ğŸ§© **Why Use Inheritance?**

1. **Reusability:** You donâ€™t need to rewrite code in every class.
2. **Extensibility:** You can add or override features easily.
3. **Organization:** It creates a natural hierarchy (e.g., Animal â†’ Dog â†’ Bulldog).
4. **Polymorphism:** Lets you treat derived objects as base objects â€” key for object-oriented design.

---

### âš™ï¸ **Types of Inheritance in C++**

| Type      | Syntax                  | Meaning                                                    |
| --------- | ----------------------- | ---------------------------------------------------------- |
| Public    | `class B : public A`    | Public and protected members of A keep their access levels |
| Protected | `class B : protected A` | Public and protected members of A become protected in B    |
| Private   | `class B : private A`   | Public and protected members of A become private in B      |

================================================================================================================================

Perfect â€” thatâ€™s exactly the kind of confusion every C++ learner has at first ğŸ˜Š
Letâ€™s clear it up step by step like in a classroom.

---

## ğŸ§© First: What are **Access Specifiers**?

Access specifiers control **who can access** the members (variables or functions) of a class.

There are **three** in C++:

| Keyword       | Who Can Access It?                                    |
| ------------- | ----------------------------------------------------- |
| **public**    | Everyone (inside or outside the class)                |
| **protected** | Only the class itself and its derived (child) classes |
| **private**   | Only the class itself (not even derived classes)      |

Example:

```cpp
class Base {
public:
    int a;         // accessible everywhere
protected:
    int b;         // accessible only in Base and its children
private:
    int c;         // accessible only inside Base
};
```

---

## ğŸ§± Now: What Happens When We Inherit?

When one class inherits another, you specify *how* it inherits:
`public`, `protected`, or `private`.

Letâ€™s see how each affects the **access level** of the inherited members ğŸ‘‡

---

### ğŸŸ¢ **Public Inheritance** (most common)

```cpp
class Derived : public Base {};
```

| Base Member | Access in Derived |
| ----------- | ----------------- |
| public â†’    | public            |
| protected â†’ | protected         |
| private â†’   | âŒ not inherited   |

âœ… Means:

* â€œIâ€™m keeping the same visibility.â€
* This is what you usually use when the derived class **is-a** type of the base class.
  (Example: a Dog *is an* Animal.)

---

### ğŸŸ¡ **Protected Inheritance**

```cpp
class Derived : protected Base {};
```

| Base Member | Access in Derived |
| ----------- | ----------------- |
| public â†’    | protected         |
| protected â†’ | protected         |
| private â†’   | âŒ not inherited   |

âœ… Means:

* The derived class can use baseâ€™s members,
* But **objects of the derived class** cannot directly access them.

---

### ğŸ”´ **Private Inheritance**

```cpp
class Derived : private Base {};
```

| Base Member | Access in Derived |
| ----------- | ----------------- |
| public â†’    | private           |
| protected â†’ | private           |
| private â†’   | âŒ not inherited   |

âœ… Means:

* The derived class gets access, but treats everything as **private**.
* Outsiders donâ€™t even know it was inherited.
* Often used when you want to reuse base functionality **without exposing** the base interface.

---

### ğŸ§  Example Summary:

```cpp
class Base {
public:
    int a = 1;
protected:
    int b = 2;
private:
    int c = 3;
};

class PublicDerived : public Base {};
class ProtectedDerived : protected Base {};
class PrivateDerived : private Base {};
```

Now look at what each can access:

```cpp
PublicDerived pd;
pd.a; // âœ… OK (public stays public)
pd.b; // âŒ Error (protected)
pd.c; // âŒ Error (private)

ProtectedDerived ptd;
ptd.a; // âŒ Error (became protected)
ptd.b; // âŒ Error (protected)
ptd.c; // âŒ Error

PrivateDerived prd;
prd.a; // âŒ Error (became private)
prd.b; // âŒ Error
prd.c; // âŒ Error
```

---

### ğŸ Key Idea to Remember

| Inheritance Type | When to Use                                                        | Behavior              |
| ---------------- | ------------------------------------------------------------------ | --------------------- |
| **public**       | â€œis-aâ€ relationship (Dog is an Animal)                             | Keeps access the same |
| **protected**    | You want derived classes to use base members, but not outside code | Hides from outside    |
| **private**      | You just want to reuse code from base, not expose it               | Hides everything      |

================================================================================================================================

Excellent ğŸ‘ğŸ‘ â€” thatâ€™s *exactly* the kind of deep question that shows youâ€™re thinking like a real C++ programmer!

Letâ€™s walk through what happens step by step â€” like a teacher explaining what the compiler actually does inside your computer.

---

## ğŸ§  Your Setup

You have something like this:

```cpp
#include <iostream>
using namespace std;

class A {
public:
    void showA() {
        cout << "Function from class A\n";
    }
};

class B : public A {
public:
    void showB() {
        cout << "Function from class B\n";
    }
};

int main() {
    B obj;
    obj.showA(); // <-- inherited from A
    obj.showB(); // <-- from B
}
```

---

## ğŸ§© Step 1: What Happens During Compilation

When the compiler sees `class B : public A`, it doesnâ€™t copy and paste code literally â€”
but **it behaves as if** all accessible members from `A` were included inside `B`.

So, conceptually, `B` now *contains*:

* its own members (`showB()`),
* plus all inherited members of `A` (`showA()`),
* plus a hidden **subobject** of type `A`.

In memory, an object of `B` actually **contains an embedded `A` object** inside it.
This is crucial.

---

## ğŸ§± Step 2: Memory Layout

When you write:

```cpp
B obj;
```

the compiler allocates enough space for **both parts**:

1. The `A` part (the base class subobject)
2. The `B` part (its own members)

Visually:

```
 -------------------------
|  A part (base members)  |
|-------------------------|
|  B part (own members)   |
 -------------------------
```

Thatâ€™s why `obj.showA()` works â€” the `A` part *exists* inside `obj`.

---

## âš™ï¸ Step 3: What Happens When You Call `obj.showA()`

When you call:

```cpp
obj.showA();
```

the compiler generates a call that looks like:

```cpp
A::showA(&obj);
```

It simply uses the **A subobject** inside `obj` to execute `A`â€™s function.
Since `showA` is not overridden, it directly calls the version from `A`.

---

## ğŸ§® Step 4: Constructor and Destructor Order

When you create a `B` object:

1. The **constructor of `A`** runs first â†’ builds the base part.
2. Then the **constructor of `B`** runs â†’ builds its own part.

When you destroy it:

1. The **destructor of `B`** runs first.
2. Then the **destructor of `A`** runs.

So the rule is:

> Construct base â†’ then derived
> Destroy derived â†’ then base

---

## ğŸ§° Example with Constructors

```cpp
#include <iostream>
using namespace std;

class A {
public:
    A() { cout << "A constructor\n"; }
    ~A() { cout << "A destructor\n"; }
};

class B : public A {
public:
    B() { cout << "B constructor\n"; }
    ~B() { cout << "B destructor\n"; }
};

int main() {
    B obj;
}
```

ğŸŸ¢ **Output:**

```
A constructor
B constructor
B destructor
A destructor
```

---

## ğŸ§© Summary

When you inherit and create a derived object:

| Step | What Happens                                                                         |
| ---- | ------------------------------------------------------------------------------------ |
| 1ï¸âƒ£  | The compiler makes the derived class *contain* a hidden subobject of the base class. |
| 2ï¸âƒ£  | When you create a derived object, it constructs both: base first, then derived.      |
| 3ï¸âƒ£  | When you call a base class method, it uses that internal base subobject.             |
| 4ï¸âƒ£  | When you destroy it, destructors go in the reverse order.                            |

---

So, to answer your question directly:

> ğŸ’¬ â€œWhen I create `B obj;` and call an inherited function from `A`, how is it created?â€

âœ… The function itself is **not recreated** â€” it already exists in the compiled code of `A`.
âœ… The **object `B`** contains an **instance of `A`** inside it, so the function has something to act on.
âœ… The compiler connects the call `obj.showA()` to `A::showA()` using that subobject.

================================================================================================================================

Excellent â€” **this is a very advanced and important question** ğŸ‘ğŸ‘
Youâ€™re now thinking like a true C++ developer who wants to understand **how inheritance interacts with copy semantics**.

Letâ€™s go slowly and clearly step by step â€” like in a real class.

---

## ğŸ§© The Situation

You have a **base class** (letâ€™s say `ClapTrap`) and a **derived class** (`FragTrap`):

```cpp
class ClapTrap {
public:
    std::string name;
    int hitPoints;

    // Base class copy constructor
    ClapTrap(const ClapTrap& other) {
        std::cout << "ClapTrap copy constructor called\n";
        name = other.name;
        hitPoints = other.hitPoints;
    }
};
```

```cpp
class FragTrap : public ClapTrap {
public:
    int energy;

    // Derived class copy constructor
    FragTrap(const FragTrap& other) : ClapTrap(other) {
        std::cout << "FragTrap copy constructor called\n";
        energy = other.energy;
    }
};
```

---

## âš™ï¸ What Happens When You Copy a Derived Object

When you write:

```cpp
FragTrap a;
FragTrap b = a; // copy constructor is called
```

ğŸ‘‰ The compiler performs the following **sequence**:

1. It first copies the **base class part** (the `ClapTrap` inside `FragTrap`).
2. Then it copies the **derived part** (`FragTrap`â€™s own members).

This mirrors **construction order** â€” base first, then derived.

---

## ğŸ§  Why You Must Call the Base Copy Constructor

When you define:

```cpp
FragTrap(const FragTrap& other) : ClapTrap(other)
```

you are explicitly telling the compiler:

> â€œHey, before I copy my own `FragTrap` members, please let the `ClapTrap` copy constructor handle the base part.â€

Otherwise, the compiler would try to use the **default constructor** of `ClapTrap`,
and that means your `ClapTrap`-related data inside the new object wouldnâ€™t be copied correctly.

---

### ğŸ§® Visual Example

Think of it like two boxes:

```
FragTrap object:
 --------------------------
| ClapTrap part | FragTrap part |
 --------------------------
```

When copying, both parts must be duplicated.

So inside `FragTrap`â€™s copy constructor:

1. `ClapTrap(other)` â†’ copies the **base part** (name, hitPoints, etc.)
2. then the body `{ ... }` â†’ copies the **derived part** (energy, etc.)

---

## ğŸ’¡ If You Donâ€™t Call the Base Copy Constructor

Then this happens:

```cpp
FragTrap(const FragTrap& other) {
    // ClapTrap default constructor is called automatically!
    energy = other.energy;
}
```

That means:

* The `ClapTrap` part inside the new `FragTrap` will be created using **ClapTrapâ€™s default constructor**,
  not the copy constructor.
* So `name`, `hitPoints`, etc. will **not be copied properly** â€” theyâ€™ll have default values instead of the values from `other`.

Thatâ€™s a **big bug**.

---

## ğŸ§° Therefore, the Correct Pattern Is:

```cpp
FragTrap::FragTrap(const FragTrap& other)
    : ClapTrap(other)  // âœ… calls the base copy constructor
{
    std::cout << "FragTrap copy constructor called\n";
    energy = other.energy; // copy derived members
}
```

---

## ğŸ“˜ Summary

| Concept                                 | Explanation                                                 |
| --------------------------------------- | ----------------------------------------------------------- |
| **Why base copy constructor is called** | To correctly copy the base class part of the derived object |
| **What happens if you skip it**         | The base part will be default-constructed instead of copied |
| **Construction order**                  | Base â†’ Derived                                              |
| **Destruction order**                   | Derived â†’ Base                                              |
| **Syntax**                              | `Derived(const Derived& other) : Base(other) { ... }`       |

---

So in your example:

```cpp
FragTrap::FragTrap(const FragTrap& other) : ClapTrap(other) {
    std::cout << "FragTrap copy constructor called\n";
}
```

means:

> â€œFirst, let the `ClapTrap` copy constructor copy all base data.
> Then Iâ€™ll handle my own extra data from `FragTrap`.â€

================================================================================================================================

Perfect ğŸ‘
Letâ€™s go **very deep** into this â€” like in a real classroom â€” to make sure you understand not just *what* happens, but *why*.

Weâ€™ll imagine the full story that the compiler and the computer follow when you copy a derived object.
So get ready for a teacher-style explanation.

---

## ğŸ§© Step 1: The Classes

Letâ€™s take your case and simplify it a bit:

```cpp
#include <iostream>
#include <string>
using namespace std;

class ClapTrap {
public:
    string name;
    int hp;

    // Normal constructor
    ClapTrap(string n, int h) : name(n), hp(h) {
        cout << "ClapTrap constructor called\n";
    }

    // Copy constructor
    ClapTrap(const ClapTrap& other) {
        cout << "ClapTrap copy constructor called\n";
        name = other.name;
        hp = other.hp;
    }
};

class FragTrap : public ClapTrap {
public:
    int energy;

    // Normal constructor
    FragTrap(string n, int h, int e) : ClapTrap(n, h), energy(e) {
        cout << "FragTrap constructor called\n";
    }

    // Copy constructor â€” CORRECT WAY âœ…
    FragTrap(const FragTrap& other) : ClapTrap(other) {
        cout << "FragTrap copy constructor called\n";
        energy = other.energy;
    }
};
```

---

## ğŸ§  Step 2: What Happens When You Create and Copy

```cpp
int main() {
    FragTrap f1("Robot", 100, 50);
    FragTrap f2 = f1;  // copy constructor called
}
```

---

## ğŸ§® Step 3: Construction Story (in correct way)

Letâ€™s break down what happens **line by line** when `FragTrap f2 = f1;` runs.

---

### ğŸ§© Step 3.1: `f2` is being created.

* The compiler sees you are copying `f1` into `f2`.
* It looks for `FragTrap(const FragTrap&)`.

It finds:

```cpp
FragTrap(const FragTrap& other) : ClapTrap(other)
```

So it says:

> â€œOkay, I must first build the base class part (`ClapTrap`) by copying `other`â€™s base part.â€

---

### ğŸ§© Step 3.2: Base Part Construction (`ClapTrap(other)`)

Now the compiler temporarily switches to `ClapTrap`:

* It calls `ClapTrap`â€™s **copy constructor**.
  Inside that function:

  ```cpp
  name = other.name;
  hp = other.hp;
  ```
* So the **base portion** of `f2` now has:

  ```
  name = "Robot"
  hp = 100
  ```
* Then it finishes `ClapTrap`â€™s copy constructor.

---

### ğŸ§© Step 3.3: Derived Part Construction (`FragTrap`â€™s own body)

Now it returns to `FragTrap`â€™s constructor body:

```cpp
energy = other.energy;
```

So `f2.energy = 50`.

Finally, the message:

```
FragTrap copy constructor called
```

is printed.

---

### ğŸ§© Step 3.4: Object Fully Built

Now `f2` is a *perfect copy* of `f1`:

```
f2.name   = "Robot"   // copied by ClapTrap
f2.hp     = 100       // copied by ClapTrap
f2.energy = 50        // copied by FragTrap
```

---

## âš™ï¸ Step 4: What Happens if You Do **Not** Call `ClapTrap(other)`

Letâ€™s see the **wrong way**:

```cpp
FragTrap(const FragTrap& other) {
    cout << "FragTrap copy constructor called\n";
    energy = other.energy;
}
```

Now what happens?

---

### ğŸ§© Step 4.1: Compilerâ€™s Default Behavior

The compiler still needs to **construct** the base part (ClapTrap) somehow.

Since you didnâ€™t tell it what to do, it uses **ClapTrapâ€™s default constructor**, not the copy one.

---

### ğŸ§© Step 4.2: Result

* `ClapTrap()` (the **default**, not copy) is called.
  That means:

  ```cpp
  name = "";     // default, not "Robot"
  hp = 0;        // default, not 100
  ```
* Then, the derived part (`FragTrap`) runs:

  ```cpp
  energy = other.energy; // copies 50
  ```

So now your `f2` looks like this:

```
f2.name   = ""      âŒ (not copied)
f2.hp     = 0       âŒ (not copied)
f2.energy = 50      âœ… (copied)
```

Thatâ€™s a **half-copied** object â€” the derived data is correct, but the base data is broken.

---

### ğŸ§¨ Side Effect

If your base class manages resources (like a file handle, pointer, or dynamic memory),
not copying it properly can cause:

* **Memory leaks**
* **Dangling pointers**
* **Program crashes**

Thatâ€™s why calling the base copy constructor is critical!

---

## ğŸ§­ Step 5: The Rule of Three (Important Concept)

Whenever your class manages resources or inherits from another class that does,
you should define:

1. **Destructor**
2. **Copy constructor**
3. **Copy assignment operator**

and each one should properly call the **base version** to handle the base part correctly.

---

## ğŸ§© Step 6: Summary Table

| Situation                 | What Happens                            | Result                  |
| ------------------------- | --------------------------------------- | ----------------------- |
| âœ… `:ClapTrap(other)` used | Base part copied using copy constructor | Correct clone of object |
| âŒ No base call            | Base part default-constructed           | Broken, incomplete copy |
| Construction order        | Base â†’ Derived                          | Always                  |
| Destruction order         | Derived â†’ Base                          | Always                  |

---

### ğŸ§  In short:

> When you copy a derived object, the compiler must also copy the **base subobject** inside it.
> If you donâ€™t tell it how, it guesses â€” and it guesses wrong!
> So you explicitly write `:Base(other)` to say: â€œUse the base copy constructor, not the default one.â€

================================================================================================================================

Excellent question again ğŸ‘ â€” this is the **core** of understanding inheritance in C++.

Letâ€™s take it slow and clear, like a teacher breaking down an abstract idea into something you can visualize.

---

## ğŸ§  What Does â€œVirtualâ€ Mean in General?

The word **â€œvirtualâ€** in C++ means:

> *â€œThis thing exists only once, even if it seems to come from multiple paths.â€*
> or
> *â€œThis behavior can be redefined dynamically (at runtime).â€*

But â€” in inheritance â€” â€œvirtualâ€ has **two main meanings**, depending on **where** you use it:

---

## 1ï¸âƒ£ **Virtual Functions** â€” for behavior (polymorphism)

and

## 2ï¸âƒ£ **Virtual Base Classes** â€” for structure (diamond problem)

Letâ€™s explain both in simple language.

---

## ğŸ§© 1. **Virtual Functions** â€” when we want *shared behavior*

Imagine this hierarchy:

```cpp
class Animal {
public:
    virtual void sound() {   // <--- virtual function
        cout << "Some generic sound\n";
    }
};

class Dog : public Animal {
public:
    void sound() override {  // override base function
        cout << "Woof!\n";
    }
};

int main() {
    Animal* a = new Dog();
    a->sound(); // ??? Which one will run?
}
```

If `sound()` were **not virtual**, this call would run `Animal::sound()`
because the type of pointer is `Animal*`.

But since it **is virtual**,
C++ looks at the *real object type* at runtime (Dog),
and runs `Dog::sound()`.

ğŸŸ¢ **Output:**

```
Woof!
```

So in short:

> ğŸ”¹ â€œvirtualâ€ makes function calls depend on the **real type** of the object,
> not on the **type of the pointer or reference**.

This is called **runtime polymorphism**.

---

### ğŸ§  Easy way to explain it to someone:

> Normally, C++ decides *which function* to call at **compile time** (static binding).
>
> But when you say `virtual`, you tell C++:
> â€œWait! Donâ€™t decide now. Decide later, at runtime, based on the real object.â€

Thatâ€™s what makes polymorphism possible.

---

## ğŸ§© 2. **Virtual Base Classes** â€” when we want *shared structure*

Now imagine this again:

```
      A
     / \
    N   M
     \ /
      G
```

Without `virtual`, both `N` and `M` bring their own copy of `A`.
So `G` ends up with **two Aâ€™s** â†’ confusion.

By writing:

```cpp
class N : virtual public A {};
class M : virtual public A {};
```

we say:

> â€œThere is only one shared `A` for everyone who inherits through me.â€

Thatâ€™s what â€œvirtual base classâ€ means â€”
the base exists only **once**, even if itâ€™s inherited multiple times.

---

### ğŸ§  Easy way to explain this to someone:

> Normally, every child gets its *own copy* of the base class.
>
> But if we say the base is **virtual**, then all children *share one single copy*.
>
> Itâ€™s like saying:
> â€œDonâ€™t give each child their own parent â€” they all share the same parent.â€

---

## ğŸ§© Comparing the Two Meanings of â€œVirtualâ€

| Type                   | Used On               | Purpose                            | When It Acts | Example                          |
| ---------------------- | --------------------- | ---------------------------------- | ------------ | -------------------------------- |
| **Virtual Function**   | A function in a class | To make behavior change at runtime | Runtime      | `virtual void sound();`          |
| **Virtual Base Class** | A base class          | To avoid duplicate base objects    | Compile time | `class N : virtual public A {};` |

---

## ğŸ§­ Short Explanation You Can Tell Someone

> In C++, **â€œvirtualâ€** means â€œmake it shared and dynamic.â€
>
> * When used on a **function**, it means â€œdecide which version to run at runtime.â€
> * When used on a **base class**, it means â€œdonâ€™t make multiple copies of this base class â€” share one.â€

Excellent â€” thatâ€™s exactly the right question to ask ğŸ‘

When we say in *virtual inheritance* that **â€œthe same parent is sharedâ€**,
yes â€” it means that **the base classâ€™s data members are also shared**.

Letâ€™s break that down carefully ğŸ‘‡

---

## ğŸ§© Example without virtual inheritance

```cpp
#include <iostream>
using namespace std;

class A {
public:
    int value;
};

class N : public A {};  // Normal inheritance
class M : public A {};  // Normal inheritance

class G : public N, public M {}; // Diamond shape

int main() {
    G g;

    g.N::value = 1;
    g.M::value = 2;

    cout << g.N::value << " " << g.M::value << endl;
}
```

ğŸŸ¢ **Output:**

```
1 2
```

Explanation:

* `G` actually has **two copies** of `A`:
  one from `N` and one from `M`.
* So `g.N::value` and `g.M::value` are *two different variables*.

---

## ğŸ§© Now with virtual inheritance

```cpp
#include <iostream>
using namespace std;

class A {
public:
    int value;
};

class N : virtual public A {}; // virtual base
class M : virtual public A {}; // virtual base

class G : public N, public M {};

int main() {
    G g;

    g.value = 10;  // only ONE A now

    cout << g.value << endl;         // ok
    cout << g.N::value << endl;      // same variable
    cout << g.M::value << endl;      // same variable
}
```

ğŸŸ¢ **Output:**

```
10
10
10
```

Explanation:

* Because of the `virtual` keyword,
  both `N` and `M` share **one common A** inside `G`.
* That means there is only **one copy** of `A::value`.
* Any change made through `N`, `M`, or directly through `G` affects the same `A`.

---

### ğŸ§  So to answer clearly:

> âœ”ï¸ Yes â€” when inheritance is **virtual**, the base classâ€™s data members are **shared** among all derived classes that inherit from it.
>
> âŒ Without virtual, each inheritance path gets its **own copy** of the base data.
Sure! Letâ€™s make it **short and clear**, like a teacher explaining in one sentence:

---

### ğŸ§© Virtual in C++

**1ï¸âƒ£ Virtual Functions:**

> Makes a function **decide which version to run at runtime** based on the real object, not the pointer type.

* Used for **polymorphism**.
* Example: `virtual void sound()` in a base class.

**2ï¸âƒ£ Virtual Base Classes:**

> Makes a base class **shared** when multiple derived classes inherit from it,
> so thereâ€™s **only one copy of its data** in the most derived class.

* Solves the **diamond problem**.
* Example: `class N : virtual public A {}`

---

âœ… **In short:**

> â€œVirtualâ€ = **shared and dynamic.â€
>
> * For functions â†’ dynamic behavior at runtime
> * For base classes â†’ shared structure in memory
